\section{Описание}
Требуется написать реализацию структуры данных "красно-чёрное деревоЭ(RB tree).
Как сказано в \cite{Kormen}: "Красно-чёрное дерево представляет собой бинарное дерево поиска с одни дополнительным байтов цвета в каждом узле.
Цвет узла может быть либо красным, либо чёрным... Бинарное дерево поиска является красно-чёрным деревом, если оно удовлетворяет следующим своёствам:
\\1. Каждый узел является либо красным, либо чёрным.
\\2. Корень дерева является чёрным узлом.
\\3. Каждый лист дерева (NULL) является чёрным узлом.
\\4. Если узел красный, то оба его дочерних узла чёрные.
\\5 Для каждого узла все простые пути от него до листьев, являющихся потомками данного узла, содержат одно и то же количество чёрных узлов.
\\В соответсвии с накладываемыми на узлы дерева ограничениями ни один простой путь от корня в красно-чёрном дереве не отличается от другого по длине более чем в два раза, так что красно-чёрные деревья являются приближенно сбалансированными."
\\Красно-чёрное дерево поддерживает операции вставки, удаления и поиска в дереве, как и обычное бинарное дерево. Однако данные операции даже в худшем случае гарантируют время выполнения O(log(n)).
В целом, сложность этих операций напрямую зависит от высоты дерева. Красно-чёрное дерево с N внутренними узлами имеет высоту, не превышающую 2*log(N+1).
\\{\bfseries Доказательство.} Докажем по индукции, что для любого x дерево с корнем 
x содержит как минимум $2^{bh(x)}$ - 1 внутренних узлов, где ${bh(x)}$ - чёрная
высота вершины $x$. Если чёрная высота равна 0, то узел $x$ - терминальный, значит по формуле поддерево узла $x$
содержит не менее $2^0 - 1 = 0$ внутренних узлов. Теперь рассмотрим общий случай для вершины $x$, которая имеет высоту $bh(x)$, каждый дочерний узел
имеет высоту либо $bh(x)$, либо $bh(x) - 1$. Предположим, что для левого и правого поддеревьев $x$ формула верна, тогда в случае, когда левое и правое поддеревья имеют чёрные высоты bh(x) - 1,
по предположению индукции мы имеем, что каждый потомок $x$ имеет как минимум $2^{bh(x)}-1$ внутренних вершин. Таким образом, дерево с вершиной в x имеет не меньше $2^{bh(x)-1}-1+2^{bh(x)-1}-1+1 = 2^{bh(x)}-1$ вершин, что показывает, что формула верна.
\\Очевидно, что в худшем случае высота дерева $bh(x)$ не больше чем в 2 раза превышет $bh(x)$, так как минимум половина вершин на пути к листу от корня, не считая корень, должны быть чёрными. Отсюда из $N \geq 2^{bh(x)} - 1$ и $2bh(x) \geq h(x) \rightarrow N \geq 2^{h(x)/2} - 1$, и значит
$h \leq 2log(N+1)$, ЧТД.
\pagebreak

\section{Исходный код}
Сначала напишем свой класс \textit{NMyStd::TItem} для хранения пар типа "ключ-значения",
где типом ключа будет массив типа \textit{char[257]}, а типом значения будет \textit{unsigned long long}.
\begin{center}Листинг item.hpp\end{center} 
\begin{lstlisting}[language=C++]
//
// item.hpp
//

#ifndef LAB2_ITEM_HPP
#define LAB2_ITEM_HPP
const long long MAX_LEN = 256;
namespace NMyStd{
    struct TItem{
        unsigned long long Value;
        char Key[MAX_LEN+1];
    };
}
#endif //LAB2_ITEM_HPP
\end{lstlisting}
В файле \textit{main.cpp} будем обрабатывать запросы, вызывая нужные методы у класса красно-чёрного дерева. В цикле \text{while} до конца файла считываем очередной запрос, выполняем операцию,
если она завершилась успехом, то выводим соответсвующее сообщение, иначе показываем сообщения о неудаче. Так как по условию мы работает с регистронезависимыми строками, то при считывании ключа через цикл привёдем его к нижнему регистру.
\begin{center}Листинг main.cpp\end{center}
\begin{lstlisting}[language=C++]
//
// main.cpp
//
#include <iostream>
#include <cstring>
#include <cctype>
#include "item.hpp"
#include "tree.hpp"

int main(){
    char readStr[MAX_LEN+1];
    NMyStd::TRBTree* rbTree = new NMyStd::TRBTree;
    while(scanf("%s", readStr) > 0){
        if (strcmp(readStr,"+") == 0) {
            char key[MAX_LEN + 1];
            unsigned long long val;
            scanf("%s%llu", key, &val);
            for (int i = 0; i < strlen(key); ++i){
                key[i] = (char)tolower(key[i]);
            }
            NMyStd::TItem item;
            item.Value = val;
            std::memcpy(item.Key, key, sizeof(char)*(MAX_LEN+1));
            if (rbTree->Insert(item)) {
                printf("OK\n");
            } else {
                printf("Exist\n");
            }
        } else if (strcmp(readStr,"-") == 0) {
            char key[MAX_LEN + 1];
            scanf("%s", key);
            for (int i = 0; i < strlen(key); ++i){
                key[i] = (char)tolower(key[i]);
            }
            if (rbTree->Remove(key)) {
                printf("OK\n");
            } else {
                printf("NoSuchWord\n");
            }
        } else if (strcmp(readStr,"!") == 0) {
            char path[MAX_LEN + 1];
            scanf("%s %s", readStr, path);
            bool isOK = true;
            if (strcmp(readStr,"Save") == 0) {
                NMyStd::TRBTree::Save(path, *rbTree, isOK);
                if (isOK) {
                    printf("OK\n");
                }
            }  else {
                NMyStd::TRBTree* tmpTreePtr = new NMyStd::TRBTree;
                NMyStd::TRBTree::Load(path, *tmpTreePtr, isOK);
                if (isOK) {
                    printf("OK\n");
                    delete rbTree;
                    rbTree = tmpTreePtr;
                } else {
                    delete tmpTreePtr;
                }
            }
        } else {
            for (int i = 0; i < strlen(readStr); ++i){
                readStr[i] = (char)tolower(readStr[i]);
            }
            NMyStd::TItem ans;
            if (rbTree->Search(readStr, ans)) {
                printf("OK: %llu\n", ans.Value);
            } else {
                printf("NoSuchWord\n");
            }
        }
    }
    delete rbTree;
    return 0;
}
\end{lstlisting}
Для написания дерева сначала опишем структуру вершины красно-чёрного дерева \textit{TRBNode}, в которой будем хранить
указатель на левого сына, правого сына и родителя. Также будем хранть цвет вершины и поле с данными типа \textit{TItem}.
Теперь создадим класс красно-чёрного дерева с одним полем - корнем дерева, и шестью пользовательскими методами: вставка,
удаление, поиск, сохранение в файл, выгрузка из файла и геттер корня дерева. Для этих шести операций напишем вспомогательные
приватные методы поиска, удаления, вставки, загрузки, выгрузки, а также напишем вспомогательные методы поворотов, перекраски
после вставки и удаления. 
\\Поиск в красно-чёрном дереве ничем не отличается от поиска в бинарном дереве. Мы также идём налево,
если ключ, который мы ищем, меньше того, что в вершине, если ключ больше, то идём направо. Если ключи равны, то мы нашли наш
элемент. Если мы дошли до NULL-листа, то такого элемента с искомым ключом нет.
\\Вставка в красно-чёрное дерево отличается от вставки в обычное бинарное дерево поиска. При вставке нужно учитывать, что некоторые
свойства дерева могут нарушиться. Новый узел в красно-чёрное дерево жобавляется на место одного из листьев, окрашивается в красный
цвет. Потом вызывается функция \textit{InsertFixUp} для восстановления свойств дерева. При вставке красной вершины может испортиться
только свойство 2 и 4. Нарушение свойства 2 будем обрабатывать сразу, вне функции \textit{InsertFixUp}. В \text{InsertFixUp} в зависимости
от цвета дяди делаем следующие действия. Если дядя красный, окрашиваем дядю и отца в чёрный, деда окрашиваем в красный и запускаем алгоритм
вверх от деда, либо, если дядя чёрный, при помощи поворотов подвешиваем поддерево с корнем-дедом за отца вершины, делая деда дочерней вершиной
отца добавленной вершины. Поиск места для вставки занимает $O(log(N))$. Так как в худшем случае мы можем перекрашивать дерево рекурсивно вплоть
до корня, то, зная ограничения на высоту красно-чёрного дерева, можно сказать, что будет не более $O(log(N))$ выполнений \textit{InsertFixUp}.
Задача, когда отец - правый сын деда решается зеркально.
\\При удалении узла с двумя не листовыми потомками в обычном двоичном дереве поиска мы ищем либо наибольший элемент в его левом поддереве, либо
наименьший элемент в его правом поддереве и перемещаем его значение в удаляемый узел. Затем мы удаляем узел, из которого копировали значение. Копирование
значения из одного узла в другой не нарушает свойств красно=чёрного дерева, так как структура дерева и цвета узлов не изменяются. Стоит заметить, что новый
удаляемый узел не может иметь сразу два дочерних нелистовых узла, так как в противном случае он не будет являться наибольшим/наименьшим элементои. Таким образом,
получается, что случай удаления узла, имеющего два нелистовых потомка, сводится к случаю удаления узла, содержащего как максимум один дочерний нелистовой узел. Удаление 
чёрного узла может нарушить свойства 2, 4 и 5. Удаление красного узла не требует починки дерева. При удалении будем рассматривать брата вершины, которая встала на место
удаленной вершины. Если после удаления две красные вершины встали подряд, то покрасим одну из них в чёрный, восстановив баланс и все свойства. Иначе, если брат красный,
то сводим задачу к той, когда брат чёрный, мы рассматриваем детей брата. Если они оба чёрные, то мы красим брата в красный, теряя красный уже во всём поддереве с корнем
в отце, запуская починку дерева уже от отца. Когда правый сын брата чёрный мы сводим задачу к той, когда правый сые красный, делая один поворот, перекрашивая брата и его 
левого сына. Наконец в этом случае мы делаем левый поворот, подвешивая поддерево за брата, меняем его цвет на цвет отца, цвет отца меняем на чёрный, как и цвет правого 
сына брата, таким образом восстанавливая баланс чёрных вершин, так как слева добавилась одна чёрная вершина. Мы проводим починку дерева, пока не дойдем до корня, либо пока
вершина, от которой мы запускаем починку, не станет красный, чтобы просто перекрасить её. Поиск удаляемой вершины занимает $O(log(N))$. Починка дерева в худшем случае занимает 
$O(log(N))$, когда мы рекурсивно поднимаемся вверх в случае "оба сына брата чёрные". Задача для случая, когда рассматриваемая вершина - правый сын отца решается зеркально.
\pagebreak

\section{Консоль}
\begin{alltt}
{\color{blue} (base) nikita@nikita-desktop:~/Diskran/lab1$ make}
g++ -O3 -std=c++14 -o solution main.cpp vector.cpp vector.h
{\color{blue} (base) nikita@nikita-desktop:~/Diskran/lab1$ cat test_input.txt}
a5db3d43b37a95cd00618a7ac3112f7e LQFZzcjKUIgaNHdxMhDRzSojQdKKdJRxqntO
d40c0348390bdb0e0fee9348cc8d2e67 vVNAzruNkZUPUUqHcmfWgkwdOGTSJeaAINZ
364590e5c89b6b1c54231793d261a3b2 wMmpTNRfxIrkciktSkSdLYabpVgehC
734bf391f564bd5aff79a1fefeb358b7 m
e31adffb1b4418881731733600387d82 vJCqcbdkeEVJLWwRbPTRWk
caf836a9f342e48deb43e8215b23b177 FbGyVbPqdyvlQoJoqmvdiaCboIkNOILfldOAPtjxbzoVUxFKSOvppxRCtf
5a3378d5ca2706bffab672e07894212b QKutCZfccVqEZORVvVxPICHQYAOemh
0472d854d83d11c287ec7d9eff9b8146 CvqgXrzHlEWFRIORDYhvJH
c41d2af1b376b9fc1f95fce356012712 SYhTAeNdhtZlTAWOreQeMNPaGgFSYNRMpoldNrUDsEAIR
8a18a352c07e3af6411007385bffd0ed ibdyiGQrGFQbLZngBwpsNoMiUrIGvkQwHwYGwVSWZ
{\color{blue} (base) nikita@nikita-desktop:~/Diskran/lab1$ ./solution < test_input.txt}
0472d854d83d11c287ec7d9eff9b8146 CvqgXrzHlEWFRIORDYhvJH
364590e5c89b6b1c54231793d261a3b2 wMmpTNRfxIrkciktSkSdLYabpVgehC
5a3378d5ca2706bffab672e07894212b QKutCZfccVqEZORVvVxPICHQYAOemh
734bf391f564bd5aff79a1fefeb358b7 m
8a18a352c07e3af6411007385bffd0ed ibdyiGQrGFQbLZngBwpsNoMiUrIGvkQwHwYGwVSWZ
a5db3d43b37a95cd00618a7ac3112f7e LQFZzcjKUIgaNHdxMhDRzSojQdKKdJRxqntO
c41d2af1b376b9fc1f95fce356012712 SYhTAeNdhtZlTAWOreQeMNPaGgFSYNRMpoldNrUDsEAIR
caf836a9f342e48deb43e8215b23b177 FbGyVbPqdyvlQoJoqmvdiaCboIkNOILfldOAPtjxbzoVUxFKSOvppxRCtf
d40c0348390bdb0e0fee9348cc8d2e67 vVNAzruNkZUPUUqHcmfWgkwdOGTSJeaAINZ
e31adffb1b4418881731733600387d82 vJCqcbdkeEVJLWwRbPTRWk
\end{alltt}
\pagebreak

