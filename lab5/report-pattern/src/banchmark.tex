\section{Тест производительности}
Алгоритм мы будем сравнивать с наивным поиском минимальнго разреза, т.е. мы будем от каждого $i[0..n]$ проходить максимум $n$ раз, чтобы
найти минимальный срез. Худшая оценка данного алгоритма $O(n^2)$, поэтому, казалось бы, суфф. дерево должно выигрывать всухую, но...

\begin{alltt}
[info] [2021-05-12 08:39:23] Running tests/05.t
Size of string is 100000
naive linearization 0 ms
suffTree linearization 104 ms
[info] [2021-05-12 08:39:23] Running tests/06.t
Size of string is 1000000
naive linearization 3 ms
suffTree linearization 1572 ms
[info] [2021-05-12 08:39:26] Running tests/07.t
Size of string is 10000000
naive linearization 19 ms
suffTree linearization 20802 ms
    
\end{alltt}

Глядя на результаты я сначала сильно удивлися, а потом вспомнил, что все тесты у меня рандомно генерируемые, т.е. в строках очень много 
различающихся символов, а т.к. второй проход можно остановить, если один из сравниваемых элементов больше или меньше другого
(в случае, если символ, перебираемый по циклу, меньше, то мы обновляем минимальный индекс и останавливаем цикл, в ином же случае, если
перебираемый по циклу символ больше того, что принадлежит текущему минимальному срезу, то просто останавливаем цикл). А значит, что второй
вложенный цикл проходит сравнительно небольшое кол-во итерация, из-за чего он почти не влияет на результат.

\pagebreak

